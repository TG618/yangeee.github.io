<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JS的原型和原型链</title>
      <link href="/2018/10/28/JS%20%E5%8E%9F%E5%9E%8B%20%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/10/28/JS%20%E5%8E%9F%E5%9E%8B%20%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li>首先普通对象（Boolean、Number、String)有各自的上层原型对象，这些原型包装了一些自身的独特方法或者重写的Object原型方法(toString)</li><li>对象.<strong>proto</strong>===函数.prototype</li><li><strong>proto</strong>是公有属性对象，会一层一层的指向上层，最终指向Object.prototype，最终会指向null（<strong>proto</strong>是都有的，不然会被gc回收，浏览器刚开始就会把所有的全部生成好：不写代码就有prototype)</li><li>比较特殊的是函数对象：<br>如果把函数看成对象，那么函数.<strong>proto</strong> === Function.prototype<br>如果把 Function 看成对象，那么 Function.<strong>proto</strong> === Function.prototype</li><li>补充下，Boolean、String、Number、Object这些原型对象都是通过构造函数实例化的，所以他们的proto===Function.prototype,也就可以理解4右边为什么都是Function.prototype</li></ol><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>实例对象被声明后可以拥有自己的属性，当然也可以通过原型链间接引用<strong>原型对象中prototype</strong>的属性，当然也可以增加原型对象的属性，特殊一点的就是如果把一个函数看做对象，那么他首先向上找的是Function.prototype(其实函数就是一种对象，是Function的实例)<br><strong>一个对象是由谁实例化的，那么这个对象就等于是由他生出来的，能通过<strong>proto</strong>引用父亲中的方法。实例对象.<strong>proto</strong>==构造函数.prototype</strong></p><font size="4" color="DodgerBlue">要学的还有很多，急也急不来:)</font> ]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 原型 原型链 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS里的类型转换、内存、拷贝</title>
      <link href="/2018/10/25/JS-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E5%86%85%E5%AD%98-%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/10/25/JS-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E5%86%85%E5%AD%98-%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<h2 id="转化成字符串"><a href="#转化成字符串" class="headerlink" title="转化成字符串"></a>转化成字符串</h2><p>老司机直接用：‘’+ xxx   这里的xxx可以是任何类型,String()也可以<br>新手用toString会导致null、undefined无法正常转换,布尔和数字可以被转换。<br>对象的话2种方法都无法变成想要的结果，会成为[object Object]。对象中的值记得加<strong>引号</strong></p><h2 id="转化成布尔"><a href="#转化成布尔" class="headerlink" title="转化成布尔"></a>转化成布尔</h2><p>新手用Boolean()方法<br>老手直接在前面加2个感叹号<br>5种类型里返回false的就5个：<br>数值：0 NaN<br>字符串：空字符串<br>null<br>undefined</p><h2 id="转化成数值"><a href="#转化成数值" class="headerlink" title="转化成数值"></a>转化成数值</h2><p><code>Number(&#39;1&#39;) ===1</code> //<br><code>parseInt(&#39;1&#39;,10)===1</code> //10必须写,parse是解析的意思<br><code>parseFloat(&#39;1.23&#39;)===1</code> //转化浮点数<br><code>‘1’-0===1</code> //老手方法<br><code>+ ‘1’ ===1</code>  //更骚,不是取绝对值的意思</p><h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><p>stack可以存值和地址，heap中可以保存函数和对象块，然后利用stack存址来引用</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>没有引用的就算垃圾，document就算引用</p><p>IE有个BUG，var a = function(){}; document.body.onclick = a<br> a = null<br>此时这个function还在被引用着，会造成内存泄露。</p><hr><p>小TIPS：</p><ol><li>当parseInt转化失败时，会返回NaN,</li><li>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去</li></ol><font size="4" color="DodgerBlue">要学的还有很多，急也急不来:)</font> ]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 类型转换 内存 拷贝 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS里的数据类型</title>
      <link href="/2018/10/20/10-20-JS%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/20/10-20-JS%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>先自我反省下：好久没写博客啦，不过学习脚步没停下。</p><p>这篇文章总结下JS数据类型里应该注意下的地方。</p><p>JS一共有7种数据类型：</p><h2 id="number"><a href="#number" class="headerlink" title="number"></a>number</h2><p>知识点：<br>-</p><ul><li>整数和小数：1 1.1 .1</li><li>科学记数法：1.23e2</li><li>二进制：0b11</li><li>八进制：011（后来 ES5 添加了 0o11 语法）</li><li>十六进制：0x11</li></ul><p>注意事项：</p><ol><li>NaN是一个告诉你不是数值的数值，并且不能等于他自己</li><li>数字1的类型不能变化</li></ol><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p> 知识点：<br>-</p><ul><li>空字符串：’’</li><li>多行字符串：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;12345&apos; +</span><br><span class="line">              &apos;67890&apos; // 无回车符号</span><br><span class="line">  或</span><br><span class="line">var s = `12345</span><br><span class="line">67890` // 含回车符号</span><br></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ol><li><p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。<br>注意，反斜杠的后面必须是换行符。PS：这种方法很烂，建议使用+拼接字符串。</p></li><li><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符。<br>但是对于字符串的改动是无效的。</p></li><li><p>每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。<br>也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。<br>ps:有些字符是四个字节JS会认为他的长度为2。</p></li><li><p>ES6可以用反引号直接括起来但是包含回车和缩进空格</p></li><li><p>\t\n1这是3个长度，反斜杠加字母算一个字符。</p></li><li>parseInt() 如果字符串头部有空格，空格会被自动去除。<br>如果parseInt的参数不是字符串，则先转为字符串再转换。<br>字符串转为整数时，是一个个字符依次转换，当遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。<br>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。                                                        </li></ol><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>知识点：<br>-</p><ul><li>object 就是上面几种基本类型（无序地）组合在一起</li><li>object 里面可以有 object</li><li>object 的 key 一律是字符串，不存在其他类型的 key</li><li>object[‘’] 是合法的</li><li>object[‘key’] 可以写作 object.key</li><li>注意 object.key 与 object[key] 不同</li><li>delete object[‘key’]</li><li>‘key’ in object</li></ul><p>注意事项：</p><ol><li>如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。方括号运算符内部还可以使用表达式。</li><li>数值键名不能使用点运算符</li><li>查看一个对象本身的所有属性，可以使用Object.keys方法<code>Object.keys(obj);</code></li><li>delete命令用于删除对象的属性，删除成功后返回true。<code>deleteobj.p</code><br>注意，删除一个不存在的属性，delete不报错，而且返回true。<br>所以不能根据这个结果判断属性是否存在。<br>delete不能删除继承的属性<code>var obj = {}; delete obj.toString // true 实际上没有删除</code></li><li>in运算符并不能判断属性是自身的还是继承的<br>hasOwnProperty()方法则可以</li><li><p>一般情况下，都是只想遍历对象自身的属性，所以使用for…in的时候，应该结合使用hasOwnProperty方法,在循环内部判断一下，某个属性是否为对象自身的属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var key in person) &#123;</span><br><span class="line">  if (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>建议不要使用with语句，可以考虑用一个临时变量代替with</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with(obj1.obj2.obj3) &#123;</span><br><span class="line">  console.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line">with就是同时操作多个对象属性</span><br><span class="line">// 可以写成</span><br><span class="line">var temp = obj1.obj2.obj3;</span><br><span class="line">console.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure></li><li><p>如果不加引号，那么key必须合法，也就是数字不能第一个等等</p></li><li>当用for-in遍历时，console.log(person.key)无法将value逐个打出来，因为用点号时的key必须是一个对象里有的key，用person[key]时Key才能作为参数。<br>obj.name obj[name] obj[‘name]   1 3是对的</li><li>typeof null // object    typeof 函数 //function</li><li>for…in循环有两个使用注意点。<br>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。<br>它不仅遍历对象自身的属性，还遍历继承的属性</li></ol><h2 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h2><p>有一个对象object现在不想给值，推荐给个null（惯例）<br>一个非对象的不想给值，推荐给个undefined，当然不写也可以，默认就是</p><h2 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h2><p>判断对错的开关，2个值false和true，和布尔的故事一样：生或死</p><h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p>暂时用不到，细节参考文章<a href="https://zhuanlan.zhihu.com/p/22652486" target="_blank" rel="noopener">symbol</a></p>]]></content>
      
      <categories>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS 数据类型 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS布局总结</title>
      <link href="/2018/09/19/CSS%20%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93/"/>
      <url>/2018/09/19/CSS%20%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>前言：关于CSS常用布局的总结，一些过时的不常用的就不写啦，喜欢的可以收藏下博客，持续更新ing :)</p><h1 id="左右布局"><a href="#左右布局" class="headerlink" title="左右布局"></a>左右布局</h1><p>最常用的布局方式，方方演示过很多次。</p><h2 id="左右浮动方式"><a href="#左右浮动方式" class="headerlink" title="左右浮动方式"></a>左右浮动方式</h2><ol><li>首先需要定义一个清除浮动的类，并把他放在父元素上0<img src="http://pf4wluvhf.bkt.clouddn.com/111.png" alt=""></li><li>子元素上左边的儿子左浮动，右边的右浮动，宽度给百分比,高度的话由子元素内容撑起来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.left &#123;</span><br><span class="line">float:left;/* 只写关键代码，以下内容同理 */</span><br><span class="line">width:50%;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">float:right;</span><br><span class="line">width:50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="flex方式"><a href="#flex方式" class="headerlink" title="flex方式"></a>flex方式</h2><p>在父元素上添加  <code>display: flex;</code> 2个子元素添加<code>flex:1;</code> 当然也可以给左边的指定宽度然后右边自适应。<br>父元素的高度等于子元素中最高的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.wrapper &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    flex:1;</span><br><span class="line">    background: #999;</span><br><span class="line">&#125;</span><br><span class="line">.context &#123;</span><br><span class="line">    flex: 1;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="左中右布局"><a href="#左中右布局" class="headerlink" title="左中右布局"></a>左中右布局</h1><h2 id="浮动方式"><a href="#浮动方式" class="headerlink" title="浮动方式"></a>浮动方式</h2><p>方法跟左右布局一样，宽度设置小于50，中间再放一个盒子即可。</p><h2 id="flex方式-1"><a href="#flex方式-1" class="headerlink" title="flex方式"></a>flex方式</h2><p>如果是三个同样宽度的，子元素设置<code>flex:1；</code>即可，不同宽度的就设置具体px</p><h2 id="绝对定位方式"><a href="#绝对定位方式" class="headerlink" title="绝对定位方式"></a>绝对定位方式</h2><p>左边元素: <code>position: absolute; left: 0;</code>右边元素: <code>position: absolute; right:0;</code><br>中间元素: <code>position: absolute;left:左边盒子宽度; right: 右边盒子宽度;</code><br><br></p><h1 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h1><h2 id="margin和width实现"><a href="#margin和width实现" class="headerlink" title="margin和width实现"></a>margin和width实现</h2><p>这种方法是最古老的并且常用的：一个有宽度的盒子给他设置<code>margin:0 atuo;</code>就可以实现居中</p><p>优点：实现方法简单易懂，浏览器兼容性强</p><p>缺点：扩展性差，无法自适应未知项情况</p><h2 id="inline-block实现"><a href="#inline-block实现" class="headerlink" title="inline-block实现"></a>inline-block实现</h2><p>子元素设置<code>display:inline-block;</code>，父元素设置<code>text-align:center;</code></p><p>优点：简单易懂，扩展性强</p><p>缺点：如果有多个子元素，如li，那么每个子元素间会存在间距，需要额外处理inline-block的浏览器兼容性，垂直间距可以使用<code>vertical-align:top;</code></p><h2 id="浮动加定位"><a href="#浮动加定位" class="headerlink" title="浮动加定位"></a>浮动加定位</h2><p>这种方法比较怪，适合ul，先给ul<code>position:absolute; left:50%;</code> 再给li<code>position:realtive: right: 50%;</code>很像左右横跳</p><p>优点：扩展性强，兼容性强</p><p>缺点：理解性难</p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>实现最为简单，父元素写<code>display:flex; justify-content:center;</code><br> 原理是居中父元素的大盒子，里面的内容就不用再多设置了</p><p>优点：方便快捷</p><p>缺点：兼容性差<br><br></p><h1 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h1><h2 id="vertical-middle"><a href="#vertical-middle" class="headerlink" title="vertical-middle"></a>vertical-middle</h2><p>通过<code>vertical-align:middle</code>实现，但需注意，生效的前提是元素的<code>display：inline-block</code>。</p><h2 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a>flex</h2><p>父元素设置<code>display:flex;</code>，子元素设置<code>align-self:center;</code></p><h2 id="父元素伪元素"><a href="#父元素伪元素" class="headerlink" title="父元素伪元素"></a>父元素伪元素</h2><p>给父元素添加一个伪元素，方法使用的是第一种，只不过不写在子元素身上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">baba::before &#123;</span><br><span class="line">  content:&apos;&apos;;</span><br><span class="line">  display:inline-blcok;</span><br><span class="line">  vertical-align:middle;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>注意:transform只对块级元素生效！当然这里申明了定位也就自动块级了<br>子元素写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position:relative;</span><br><span class="line">top: 50%;</span><br><span class="line">transform:translateY(-50%);</span><br></pre></td></tr></table></figure></p><p>也可以父元素写<code>position:relative;</code>子元素写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">position:absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">transform:translateY(-50%);</span><br></pre></td></tr></table></figure></p><p><br></p><h1 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h1><ol><li>内联元素之间会有小间隙，可以给父元素添加<code>font-size:0;</code>解决</li></ol>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS 布局 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS笔记</title>
      <link href="/2018/09/16/CSS%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/09/16/CSS%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>前言：主要记录下笔记吧，毕竟学的不深，喜欢的可以收藏下博客，持续更新ing :)</p><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><ol><li><p>3种方法：内联样式，style标签法，外部样式。<br>还有一种不常用：@import (./xxx.css); 在当前的CSS文件里再引用另外一个css</p></li><li><p>link中的rel=relationship关系的意思。<br> <code>&lt;link rel=“stylesheet&quot; href=&quot;xxx&quot;&gt;</code></p></li><li><p>浮动可以让导航栏横着排，儿子写<code>float:left</code> ，清除浮动可以给父亲一个:<br><img src="http://pf4wluvhf.bkt.clouddn.com/111.png" alt="clearfix"></p></li><li><p>使用边框大法可以快速看见BUG所在</p></li><li><p>如果给导航栏元素一个hover后的边框，会导致往左右顶，这个时候就要套路：先给元素直接加一个边框。</p></li><li><p>如果a标签的高度比li还要高了，可以给a一个<code>display:block</code>，应该是把父元素高度撑起来</p></li><li><p>span和span之间如果在vscode里写成2行，那么HTML里就会有空格，写成一行就没了</p></li><li><p>如果父元素内2个儿子，一个写了浮动，另外一个也要写，不然会出现BUG，不好对齐。<br>保证左右2个儿子总高度一致可以居中，不太居中的话就调节其中一个的<code>padding</code></p></li><li><p>div等块级高度由其内部文档流元素的高度总和决定。<br> 文档流：文档内元素的流动方向</p></li><li><p>浏览器不敢把一个span中的一段很长的话打断（热干面）除非使用<code>word-break</code>属性来设置</p></li><li><p><code>font-size</code>的像素指的是字体最高的一端到最低一端的高度</p></li><li><p>字体是基线对齐的，每个字体都有一个建议行高，可以设置<code>line-height</code>来控制。<br><code>line-height</code> 的值是多少像素，那么 span 所占的高度就是多少</p></li><li><p><code>display: fix</code>会让元素脱离文档流，并且会缩起来，也就是原本在导航栏右边的文字又到左边来了</p></li><li><p>BUG来源：<br>–给一个固定的高度<code>height</code><br>–添加宽度<code>width:100%</code> //如果不得不加造成元素宽度大于body的BUG，只能多添加一个div，然后在这个div进行padding等操作</p></li><li><p>设置背景图可以有<code>background-size:cover</code>//图片自适应宽度。还有<code>background-poditioin:center center</code>//居中</p></li><li><p>尽量用<code>max-width</code>来代替<code>width</code>，前者会自适应</p></li><li><p>做span的宽度高度时，不要用width和height，应该用<code>padding</code>来撑开，这样子改需求也不会出错</p></li><li><p><code>border-top-width</code>的宽度为0，那么这个边框的上半部分就是0，只有下面的一半了，当然div的高度和宽度要是0</p></li><li><p>绝对定位子元素一个<code>position: absolute</code>，父元素<code>positiion:relative</code></p></li><li><p>如果一个div给了宽度，再给他添加padding，他会变胖<br>所以一般会在里面再新建一个div，专门用来加padding布局，子元素横向布局直接浮动套路就好 </p></li><li><p>如果一个footer放了svg图标后，上下空隙不同，那么给svg加一个属性<code>vertical-align:top</code></p></li><li><p>当用<code>dl dt dd</code>做那种左右分布的布局时，先使用float让dd居于一行，在给dt一个宽度百分比，dl一个宽度百分比<br>2个加起来要是100%，上下间隙给dd加padding</p></li><li><p>span设置font-size:14px,里面的文字不一定是14px</p></li><li><p><code>display:inline</code>的元素设置<strong>宽高</strong>是无效的，设置<code>magin-top bottom</code>是无效的</p></li></ol>]]></content>
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML常用标签介绍</title>
      <link href="/2018/09/10/9-10/"/>
      <url>/2018/09/10/9-10/</url>
      <content type="html"><![CDATA[<h1 id="常用的HTML标签"><a href="#常用的HTML标签" class="headerlink" title="常用的HTML标签"></a>常用的HTML标签</h1><h2 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h2><p>　　<br>　　<span style="color:DodgerBlue; font-size:1.3em;">div</span>标签定义文档中的分区或节（division/section），可以把文档分割为独立的、不同的部分，主要用于布局。</p><p>　　<span style="color:DodgerBlue; font-size:1.3em;">aside</span>标签的内容可用作文章的侧栏，<span style="color: #ff0000;">html5新增标签</span>。</p><p>　　<span style="color:DodgerBlue; font-size:1.3em;">header</span>标签定义页面的头部（介绍信息），<span style="color: #ff0000;">html5新增标签</span>。</p><p>　　<span style="color:DodgerBlue; font-size:1.3em;">section</span>标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分，<span style="color: #ff0000;">html5新增标签</span>。</p><p>　　<span style="color:DodgerBlue; font-size:1.3em;">footer</span> 标签定义文档或节的页脚，通常包含文档的作者、版权信息、使用条款链接、联系信息等等，<span style="color: #ff0000;">html5新增标签</span>。</p><p>　　<span style="color:DodgerBlue; font-size:1.3em;">article</span>标签规定文章独立的其他内容，比如：标题、内容、评论，<span style="color: #ff0000;">html5新增标签</span>。</p><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><p>　　h1-h6标签可定义标题</p><p>　　p标签定义段落</p><p>　　b/strong标签加粗</p><p>　　em标签来表示强调的文本，斜体</p><p>　　strong标签表示重要文本</p><p>　　u标签下划线</p><p>　　s标签删除线<br>　<br>　　br标签表示回车换行</p><p>　　hr标签表示水平线</p><p>　　span标签被用来组合文档中的行内元素。</p><p>　　blockquote标签表示块引用</p><p>　　pre标签可定义预格式化的文本，保持原有格式的一种标签。</p><p>　　sub标签下标，sup标签上标</p><h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><p>　　img标签主要在网页中插入图像，可以定义图片替换文本、显示宽度和高度、是否带边框，建议等比例设置，否则图像会变形。</p><p>　　 <code>&lt;img src=&quot;图片地址&quot; alt=&quot;替换文本，图片打不开的时候显示&quot; width=&quot;图片宽度&quot; height=&quot;高度&quot; border=&quot;0&quot; /&gt;</code></p><p>　　audio标签定义声音，比如音乐或其他音频流。<span style="color: #ff0000;">html5新增标签</span>。</p><p>　　<code>&lt;audio src=&quot;someaudio.wav&quot;&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt;</code></p><p>　　video标签定义视频，比如电影片段或其他视频流。<span style="color: #ff0000;">html5新增标签</span>。</p><p>　　<code>&lt;video src=&quot;movie.ogg&quot; controls=&quot;controls&quot;&gt;您的浏览器不支持 video 标签。&lt;/video&gt;</code></p><h2 id="序列化标签"><a href="#序列化标签" class="headerlink" title="序列化标签"></a>序列化标签</h2><ol><li>ul和li是无序列表标签</li><li>ol和li有序列表标签，可以使用type属性规定有序列表符号的类型。<br>1 按数字有序排列，为默认值，（1、2、3、4）<br>a 按小写字母有序排列，（a、b、c、d）<br>A 按字母大写有序排列，（A、B、C、D）<br>i 按小写罗马字母有序，（i, ii, iii, iv）<br>I 按小写罗马字母有序，（I, II, III, IV）。</li><li>dl标签定义了定义列表（definition list），dl标签用于结合 dt（定义列表中的项目）和 dd（描述列表中的项目）。</li></ol><h2 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h2><ol><li>3部分<code>&lt;thead&gt;&lt;tbody&gt;&lt;tfoot&gt;</code></li><li><code>thead</code>里应该写<code>th</code>来表示标题，语义化 ,当然其他2个大标签里也可以写，是标题就应该用</li><li>可以给<code>&lt;th&gt;&lt;td&gt;</code>中留空白来让显示空白效果</li><li><p>colgroup用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;colgroup&gt;</span><br><span class="line">      &lt;col width=100&gt;//第一列的宽度设置</span><br><span class="line">      &lt;col bgcolor width=100&gt;//bgcolor不推荐了</span><br><span class="line">      &lt;col width=100&gt;//第三节列的宽度设置</span><br><span class="line">      &lt;col width=100&gt;</span><br><span class="line">&lt;/colgroup&gt;</span><br></pre></td></tr></table></figure></li><li><p>浏览器会自动纠正三个大标签的顺序</p></li><li>table有个属性是<code>border</code><br> CSS可以使用<code>border-collapse: collapse</code>来合并边框</li></ol><p>本文参考链接： <a href="http://www.divcss5.com/html/h50219.shtml" target="_blank" rel="noopener">HTML常用标签</a></p><font size="4" color="DodgerBlue">要学的还有很多，急也急不来:)</font> ]]></content>
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML 标签 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>W3C、MDN、HTML部分标签介绍</title>
      <link href="/2018/09/08/9-8/"/>
      <url>/2018/09/08/9-8/</url>
      <content type="html"><![CDATA[<h1 id="W3C"><a href="#W3C" class="headerlink" title="W3C"></a>W3C</h1><p>　　万维网（World Wide Web）是作为欧洲核子研究组织的一个项目发展起来的，在那里 Tim Berners-Lee 开发出万维网的雏形。Tim Berners-Lee- 万维网的发明人和万维网联盟的主任。<br>　　<br>　　万维网联盟，又称W3C理事会。1994年10月在麻省理工学院计算机科学实验室成立。建立者是万维网的发明者蒂姆·伯纳斯·李。<br>　　<br>　　W3C 最重要的工作是发展 Web 规范，这些规范描述了 Web 的通信协议（比如 HTML 和 XHTML）和其他的构建模块。　<br>　　<br>　　每项 W3C 推荐的发展是通过由会员和受邀专家组成的工作组来完成的。工作组的经费来自公司和其他组织，并会创建一个工作草案，最后是一份提议推荐。一般来说，为了获得正式的批准，推荐都会被提交给 W3C 会员和主任。</p><h1 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h1><p>　　Mozilla 开发者网络（MDN）提供有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。它还记录了  Mozilla 产品的文档，例如 Firefox OS。</p><p>　　Mozilla开发者网络（MDN）是一个完整的学习平台，你可以在这里深入学习网络技术以及能够驱动网络的软件。</p><h1 id="HTML所有标签列表"><a href="#HTML所有标签列表" class="headerlink" title="HTML所有标签列表"></a>HTML所有标签列表</h1><p>　　太多了就直接贴MDN传送门了。。。。。。<br>　　<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/HTML5/HTML5_element_list" target="_blank" rel="noopener">标签列表（含HTML5）</a></p><h1 id="空标签"><a href="#空标签" class="headerlink" title="空标签"></a>空标签</h1><p>　　一个空元素（empty element）可能是 HTML，SVG，或者 MathML 里的一个不可能存在子节点（例如内嵌的元素或者元素内的文本）的element。</p><p>　　HTML，SVG 和 MathML 的规范都详细定义了每个元素能包含的具体内容（define very precisely what each element can contain）。许多组合是没有任何语义含义的，比如一个 <code>&lt;audio&gt;</code> 元素嵌套在一个 <code>&lt;hr&gt;</code> 元素里。</p><p>　　在 HTML 中，通常在一个空元素上使用一个闭标签是无效的。例如， <code>&lt;input type=&quot;text&quot;&gt;&lt;/input&gt;</code> 的闭标签是无效的 HTML。　　　　</p><h1 id="可替换元素"><a href="#可替换元素" class="headerlink" title="可替换元素"></a>可替换元素</h1><p>　　在CSS里，可替换元素(replaced element)的展现不是由CSS来控制的。这些元素是一类外观渲染独立于CSS的外部对象。典型的可替换元素有<code>&lt;img&gt;、&lt;object&gt;、&lt;video&gt;</code>和表单元素，如<code>&lt;textarea&gt;、&lt;input&gt;</code>。<br>　　某些元素只在一些特殊情况下表现为可替换元素，例如<code>&lt;audio&gt;</code>和<code>&lt;canvas&gt;</code>。通过CSS的content属性来插入的对象被称为匿名可替换对象(annoymous replaced elements)。<br>　　CSS在某些情况下会对可替换元素做特殊处理，比如计算外边距和一些auto值。<br>　　需要注意的是，一部分（并非全部）可替换元素，本身具有尺寸和基线(baseline)，会被像vertical-align之类的一些CSS属性用到。<br>　　<br>本文参考链接：<a href="https://en.wikipedia.org/wiki/World_Wide_Web_Consortium" target="_blank" rel="noopener">W3C</a></p><font size="4" color="DodgerBlue">要学的还有很多，急也急不来:)</font> ]]></content>
      
      <categories>
          
          <category> 每周一篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP的简单介绍及查看请求与响应</title>
      <link href="/2018/09/04/9-4/"/>
      <url>/2018/09/04/9-4/</url>
      <content type="html"><![CDATA[<h1 id="HTTP-请求包括哪些部分，如何用Chrome开发者工具查看-HTTP-请求内容"><a href="#HTTP-请求包括哪些部分，如何用Chrome开发者工具查看-HTTP-请求内容" class="headerlink" title="HTTP 请求包括哪些部分，如何用Chrome开发者工具查看 HTTP 请求内容"></a>HTTP 请求包括哪些部分，如何用Chrome开发者工具查看 HTTP 请求内容</h1><p>HTTP 的作用就是指导浏览器和服务器如何进行沟通。<br>一个请求一共分为4部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 动词 路径 协议/版本  //动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Key3: value3</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line">3 //此处是一个空格，必填，分割2、4部分</span><br><span class="line">4 要上传的数据</span><br></pre></td></tr></table></figure></p><h2 id="用-Chrome-发请求"><a href="#用-Chrome-发请求" class="headerlink" title="用 Chrome 发请求"></a>用 Chrome 发请求</h2><ol><li><p>打开 Network</p></li><li><p>地址栏输入网址</p></li><li><p>在 Network 点击，查看 request，点击「view source」</p></li><li><p>点击「view source」</p></li><li><p>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到  </p></li></ol><h1 id="HTTP-响应包括哪些部分，如何用Chrome开发者工具查看-HTTP-响应内容"><a href="#HTTP-响应包括哪些部分，如何用Chrome开发者工具查看-HTTP-响应内容" class="headerlink" title="HTTP 响应包括哪些部分，如何用Chrome开发者工具查看 HTTP 响应内容"></a>HTTP 响应包括哪些部分，如何用Chrome开发者工具查看 HTTP 响应内容</h1><p>一个响应一共分为4部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 协议/版本号 状态码 状态解释</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Content-Length: 17931</span><br><span class="line">2 Content-Type: text/html</span><br><span class="line">3</span><br><span class="line">4 要下载的内容</span><br></pre></td></tr></table></figure></p><h2 id="用-Chrome-查看响应内容"><a href="#用-Chrome-查看响应内容" class="headerlink" title="用 Chrome 查看响应内容"></a>用 Chrome 查看响应内容</h2><ol><li><p>打开 Network</p></li><li><p>地址栏输入网址</p></li><li><p>选中第一个响应</p></li><li><p>查看 Response Headers，点击「view source」</p></li><li><p>会看到响应的前两部分</p></li><li><p>查看 Response 或者 Preview，你会看到响应的第 4 部分    </p></li></ol><h1 id="如何使用curl命令"><a href="#如何使用curl命令" class="headerlink" title="如何使用curl命令"></a>如何使用curl命令</h1><p>简介: curl是利用URL语法在命令行方式下工作的开源文件传输工具.</p><p>向百度发送一个post请求,请求包含数据 “1234567890”<br><code>curl -X POST -d &quot;1234567890&quot; -s -v -H -- &quot;https://www.baidu.com&quot;</code><br>其中-s表示silent模式，不显示进度和错误.<br>-v 展示curl的版本<br>-H 表示响应头<br>当然curl还有很多可以配置的命令，可以看见更多详细信息</p><p>本文参考链接：<a href="https://curl.haxx.se/docs/manpage.html" target="_blank" rel="noopener">curl命令详解(需翻墙)</a></p><font size="4" color="DodgerBlue">要学的还有很多，急也急不来:)</font> ]]></content>
      
      <categories>
          
          <category> 每周一篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>封装的数据调用JS文件使用react路由</title>
      <link href="/2018/06/03/6-3/"/>
      <url>/2018/06/03/6-3/</url>
      <content type="html"><![CDATA[<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>react前面文档看的还挺爽，结果试着玩了玩坑太多了，react和router的版本升级导致基本上搜资料=送命，有一个官方的文档还是3.0的，所以英语还是很重要的，来世做个歪果仁。</p><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><p>&emsp;&emsp;<font size="4">这个遇到坑的需求是：已经提取了一个fetch.js作为调取数据的通用接口，然后在用户查看数据列表时，如果不是处于登陆状态则自动路由到登陆界面。<br>&emsp;&emsp;狗屎的react-router升级到了4.0，之前的browser.history没了，看了半天官方文档和资料没看到解决方法，可能之后的全家桶里有，但是总不可能挖了坑不跳，于是只能改成HashRouter.当然HashRouter并不是推荐做法，只是玩具阶段随便了  </font></p><pre><code>import { Route, HashRouter as Router} from &apos;react-router-dom&apos;;  </code></pre><p>fetch.js  </p><pre><code>if (res.status === 401) {         window.location.replace(&quot;#/login&quot;);       return Promise.reject(&apos;Unauthorized.&apos;);     }   </code></pre><p>基本的功能做的差不多了，上张图书列表的图，有新点子就搞一搞，全家桶还没用全，再搞个框架做做样式试试.<br><img src="https://i.imgur.com/ZBbSG3q.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>react初体验、博客重构、ES6</title>
      <link href="/2018/05/21/5-21/"/>
      <url>/2018/05/21/5-21/</url>
      <content type="html"><![CDATA[<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><p>&emsp;&emsp;<font size="4">react与vue相比在于更加灵活，文档其实写的也非常仔细，并且更加偏重项目。</font>   </p><p>&emsp;&emsp;<font size="4">react在编写上推荐使用JSX来写渲染模板，简单明了。并且使用很多ES6语法糖。数据流仍然是从上往下的，与vue不同的是：react在一般情况下更推荐使用<font color="red" size="5"><strong>状态提升</strong></font>而不是<font color="lueb" size="5"><strong>双向绑定</strong></font>,虽然前者写的代码更多一点，但是可以更快地寻找和定位bug。 </font>  </p><p>&emsp;&emsp;<font size="4">react中常常使用组合的方式来编写WEB，前期虽然可能会比继承付出更多的代码，但是随着项目越来越大，组件的复用会使代码越来越“少”。如果当一个组件里条件或逻辑变得过于复杂，可能就是一个提取组件的好机会。</font><br>&emsp;&emsp;<font size="4">会尽快开始做一个react入门级的应用来练习，然后就是看看成熟应用的逻辑与代码，当然vue那边也不能放下，跟着做做小玩意。</font>  </p><h2 id="博客重构"><a href="#博客重构" class="headerlink" title="博客重构"></a>博客重构</h2><p>&emsp;&emsp;<font size="4">因为重装系统导致之前的文件全部丢失，于是干脆重新玩了下博客，使用了更加简洁清新的风格，未来应该会多做记录，便于复习和进步。 不过markdown刚开始用有点难受</font> </p><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>&emsp;&emsp;<font size="4">平常抽空一直在复习JS高程，之前有听说ES6但是一直没花心思看。现在刚好在看react于是开始挖坑。ES6在17年的时候貌似兼容性已经非常好了，当然直接学的话反正有babel也没什么问题，但是可能看ES5的代码会很难受，所以还是选择齐头并进吧。</font></p><font size="4" color="DodgerBlue">要学的还有很多，急也急不来:)</font> ]]></content>
      
      <categories>
          
          <category> 每周一篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从新开始 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
